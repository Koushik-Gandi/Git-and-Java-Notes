 
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+ Drop persons table and recreate it
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

use pragati

db.persons.drop()

db.persons.insert ( {
	name: {first: 'Harish', last: 'Chandra'},
	gender: 'M',
	yearOfBirth: 1962,
	livesIn: 'Mumbai',
	countriesVisited: ['India', 'Singapore', 'Thailand', 'United Kingdom', 'Spain', 'Denmark', 'United States of America'],
	languages: [
		{name: 'Hindi', proficiency: 'Fluent'},
		{name: 'English', proficiency: 'Fluent'},
		{name: 'Sanskrit', proficiency: 'Intermediate'} ]
} )

db.persons.insert ( {
	name: {first: 'Zoa', last: 'Hendrik'},
	gender: 'F',
	yearOfBirth: 1988,
	livesIn: 'Barcelona',
	countriesVisited: ['Spain', 'Denmark', 'France'],
	languages: [
		{name: 'Spanish', proficiency: 'Fluent'},
		{name: 'Catalan', proficiency: 'Fluent'},
		{name: 'English', proficiency: 'Intermediate'} ],
	married: 'No'
} )

db.persons.insert ( {
	name: {first: 'Narayan', last: 'Sundaram'},
	gender: 'M',
	yearOfBirth: 1960,
	livesIn: 'Jaipur',
	counriesVisited: ['India', 'United States of America', 'Netherlands', 'China'],
	languages: [
		{name: 'Tamil', proficiency: 'Fluent'},
		{name: 'English', proficiency: 'Fluent'},
		{name: 'Hindi', proficiency: 'Intermediate'},
		{name: 'Chinese', proficiency: 'Intermediate'} ],
	married: 'Yes'
} )

db.persons.insert ( {
	name: {first: 'Shailesh', last: 'Sharma'},
	gender: 'M',
	yearOfBirth: 1962,
	livesIn: 'Singapore',
	countriesVisited: ['India', 'Singapore', 'China', 'Taiwan', 'United States of America', 'Sri Lanka', 'Mayalsia', 'Australia'],
	languages: [
		{name: 'Hindi', proficiency: 'Fluent'},
		{name: 'English', proficiency: 'Fluent'} ]
} ) 

db.persons.insert ( {
	name: {first: 'Mark', last: 'Smith'},
	gender: 'M',
	livesIn: 'Chicago',
	countriesVisited: ['United States of America', 'Canada', 'France', 'Spain', 'India', 'Australia'],
	languages: [ {name: 'English', proficiency: 'Fluent'} ]
} )

db.persons.insert ( {
	name: {first: 'Rita', last: 'Chauhan'},
	gender: 'F',
	yearOfBirth: 1989,
	livesIn: 'Mumbai',
	countriesVisited: ['India'],
	languages: [
		{name: 'Hindi', proficiency: 'Fluent'},
		{name: 'English', proficiency: 'Fluent'} ],
	married: 'No'
} )

db.persons.insert ( {
	name: {first: 'Liza', last: 'Bordelon'},
	gender: 'F',
	yearOfBirth: 1971,
	livesIn: 'Minneapolis',
	countriesVisited: ['United States of America', 'Canada'],
	languages: [
		{name: 'English', proficiency: 'Fluent'},
		{name: 'French', proficiency: 'Fluent'},
		{name: 'German', proficiency: 'Intermediate'},
		{name: 'Greek', proficiency: 'Intermediate'},
		{name: 'Latin', proficiency: 'Intermediate'},
		{name: 'Sanskrit', proficiency: 'Beginner'} ]
} )

db.persons.insert ( {
	name: {first: 'Jenny', last: 'Jones'},
	gender: 'F',
	yearOfBirth: 1985,
	livesIn: 'Oxford',
	countriesVisited: ['United Kingdom'],
	languages: [ {name: 'English', proficiency: 'Fluent'} ],
	married: 'No'
} )

db.persons.insert ( {
	name: {first: 'Sapna', last: 'Chetri'},
	gender: 'F',
	yearOfBirth: 1989,
	livesIn: 'Siliguri',
	countriesVisited: ['India'],
	languages: [
		{name: 'Nepali', proficiency: 'Fluent'},
		{name: 'Hindi', proficiency: 'Fluent'},
		{name: 'English', proficiency: 'Intermediate'} ],
	married: 'No'
} )

db.persons.insert ( {
	name: {first: 'Jenny', middle: 'H', last: 'Jones'},
	gender: 'F',
	yearOfBirth: 1988,
	livesIn: 'London',
	countriesVisited: ['United Kingdom'],
	languages: [ {name: 'English', proficiency: 'Fluent'} ],
	married: 'Yes'
} )

db.persons.insert ( {
	name: {first: 'Lakhpa', last: 'Sherpa'},
	gender: 'M',
	yearOfBirth: 1989,
	lievsIn: 'Gangtok',
	countriesVisited: ['India'],
	languages: [
		{name: 'Nepali', proficiency: 'Fluent'},
		{name: 'English', proficiency: 'Fluent'},
		{name: 'Hindi', proficiency: 'Intermediate'} ],
	married: 'No'
} )

db.persons.insert ( {
	name: {first: 'Anita', last: 'Gogia'},
	gender: 'F',
	yearOfBirth: 1965,
	livesIn: 'New Delhi',
	countriesVisited: ['India', 'United Kingdom', 'Canada', 'United States of America'],
	languages: [
		{name: 'Hindi', proficiency: 'Fluent'},
		{name: 'Punjabi', proficiency: 'Fluent'},
		{name: 'English', proficiency: 'Fluent'} ],
	married: 'Yes'
} )

db.persons.insert ( {
	name: {first: 'Neeharika', last: 'Chauhan'},
	gender: 'F',
	yearOfBirth: 1988,
	livesIn: 'Jaipur',
	countriesVisited: ['India'],
	languages: [
		{name: 'Hindi', proficiency: 'Fluent'},
		{name: 'English', proficiency: 'Intermediate'} ],
	married: 'No'
} )

db.persons.insert ( {
	name: {first: 'Nancy', last: 'Karin'},
	gender: 'F',
	yearOfBirth: 1992,
	livesIn: 'Montreal',
	countriesVisited: ['Canada', 'United States of America'],
	languages: [
		{name: 'English', proficiency: 'Fluent'},
		{name: 'French', proficiency: 'Fluent'},
		{name: 'German', proficiency: 'Intermediate'},
		{name: 'Greek', proficiency: 'Intermediate'},
		{name: 'Latin', proficiency: 'Intermediate'},
		{name: 'Sanskrit', proficiency: 'Beginner'} ]
} )

db.persons.count()

-- In Mongo shell

db.persons.drop()

-- Find all females
db.persons.find( {gender: 'F'} )
db.persons.find( {gender: 'F'} ).pretty()
db.persons.find( {gender: 'F'} ).count()
db.persons.find( {gender: 'F'}, {name: 1} )
db.persons.find( {gender: 'F'}, {name: 1, _id: 0} )
db.persons.find( {gender: 'F'}, {name: true, _id: false} )
db.persons.find( {gender: 'F'}, {name: 1, yearOfBirth: 1} )
db.persons.find( {gender: 'F'}, {name: 1, yearOfBirth: 1, _id: 0} )
db.persons.find( {gender: 'F'}, {name: 1, yearOfBirth: 1, _id: 0, married: 0} ) // This gives an error: "cannot mix including and excluding fields".

-- Find names of all persons
db.persons.find (
	{},
	{name: 1, _id: 0}
)

-- Find all people living in Mumbai
db.persons.find (
	{livesIn: 'Mumbai'}
)

-- Find all people living in Mumbai or Jaipur
db.persons.find ( 
	{livesIn: {$in: ['Mumbai', 'Jaipur'] } } 
).pretty()

db.persons.find ( 
	{livesIn: {$in: ['Mumbai', 'Jaipur'] } },
	{name: 1, _id: 0} 
).pretty()

-- All people born before 1980
db.persons.find (
	{yearOfBirth: {$lt: 1980} },
	{name: 1, yearOfBirth: 1, _id: 0}
).pretty()

-- All persons not living in Jaipur
db.persons.find (
	{livesIn: {$ne: 'Jaipur'} },
	{name: 1, livesIn: 1, _id: 0}
).pretty()

-- All persons who have visited India, United States of America and Singapore
db.persons.find (
	{countriesVisited: {$all: ['India', 'United States of America', 'Singapore'] } },
	{name: 1, countriesVisited: 1, _id: 0}
).pretty()

-- Find all persons with first name as 'Sapna'
db.persons.find (
	{'name.first' : 'Sapna'},
	{name: 1, _id: 0}
).pretty()

-- Find all persons whose 'name' subdocument has exactly the same fields, with the given values, in the same order
db.persons.find (
	{name: {first: 'Jenny', last: 'Jones'} },
	{name: 1, _id: 0}
)

-- Find all persons with 'Jenny' as first name and 'Jones' as last name
db.persons.find (
	{'name.first': 'Jenny', 'name.last': 'Jones'},
	{name: 1, _id: 0}
)

-- Find all persons who have visited India
db.persons.find (
	{countriesVisited: 'India'},
	{name: 1, countriesVisited: 1, _id: 0}
)

-- Find all persons who have visited Canada and United States of America. But the following query returns only those documents
-- where the data is exactly as given below and in the same order.
db.persons.find (
	{countriesVisited: ['Canada', 'United States of America'] },
	{name: 1, countriesVisited: 1, _id: 0}
)

-- This is the correct query. Though if you were looking for those people who have visited only these two countries and 
-- no other country, this will not work.
db.persons.find ( 
	{countriesVisited: {$all: ['Canada', 'United States of America'] } }, 
	{name: 1, _id: 0} 
)

-- Find all persons whose first country visited is India
db.persons.find (
	{'countriesVisited.0': 'India'},
	{name: 1, countriesVisited: 1, _id: 0}
)

-- Find all persons whose first language is 'English'
db.persons.find (
	{'languages.0.name': 'English'},
	{name: 1, languages: 1, _id: 0}
)

-- Find all persons who know English
db.persons.find (
	{'languages.name': 'English'},
	{name: 1, languages: 1, _id: 0}
)

-- Find all persons who either live in Mumbai or have visited India
db.persons.find (
	{$or: [
		{livesIn: 'Mumbai'},
		{countriesVisited: 'India'}
	] },
	{name: 1, livesIn: 1, countriesVisited: 1, _id: 0}
)

-- Find all persons who have visited India or know Hindi
db.persons.find (
	{$or: [
		{countriesVisited: 'India'},
		{'languages.name': 'Hindi'}
	] },
	{name: 1, countriesVisited: 1, languages: 1, _id: 0}
).pretty()

-- Find all persons who have visited India and know Hindi
db.persons.find (
	{$and: [
		{countriesVisited: 'India'},
		{'languages.name': 'Hindi'} ] },
	{name: 1, countriesVisited: 1, languages: 1, _id: 0}
).pretty()

-- Find all persons who are fluent in English.
-- The following is incorrect: it will find all persons who know English and are fluent in any one langauge.
db.persons.find ( 
	{$and: [
		{'languages.name': 'English'}, 
		{'languages.proficiency': 'Fluent'} ] }, 
	{name: 1, languages: 1, _id: 0} 
).pretty()

-- What we need is to compare language name and proficiency level within the same array element. This is the right query:
db.persons.find (
	{languages: 
		{$elemMatch: 
			{name: 'English', proficiency: 'Fluent'} } },
	{name: 1, languages: 1, _id: 0}
).pretty()

-- Find all persons with fluency in English or Hindi
db.persons.find (
	{languages: {$elemMatch: {
		name: {$in: ['English', 'Hindi'] }, 
		proficiency: 'Fluent'
	} } },
	{name: 1, languages: 1, _id: 0}
).pretty()

-- Find all persons who have visited India and are fluent in Hindi
db.persons.find (
	{countriesVisited: 'India', languages: {$elemMatch: {name: 'Hindi', proficiency: 'Fluent'} } },
	{name: 1, countriesVisited: 1, languages: 1, _id: 0}
)

-- All males born before 1970 and all females born before 1980.
db.persons.find (
	{$or: [
		{gender: 'M', yearOfBirth: {$lt: 1970} },
		{gender: 'F', yearOfBirth: {$lt: 1980} }
	] },
	{name: 1, gender: 1, yearOfBirth: 1, _id: 0}
)

-- Find people whose first name contains the letter “a”
db.persons.find ({'name.first': /a/}, {name: true, _id: false})

-- Where first name begins with ‘A’
db.persons.find ({'name.first': /^A/}, {name: true, _id: false})

-- Where name begins 'Na'
db.persons.find ({'name.first': {$regex: /^na/i}}, {name: 1, _id: 0})
-- alternatively
db.persons.find ({'name.first': {$regex: /^na/, $options: 'i'}}, {name: 1, _id: 0})

-- Where name ends with 'sh'
db.persons.find ({'name.first': {$regex: /sh$/}}, {name: true, _id: false})

-- For all females, return their name and the first three countries visited by them
db.persons.find ( 
	{gender: 'F'},
	{name: 1, countriesVisited: {$slice: 3}, _id: 0}
)

-- Show all persons, sorted in ascending order of their year of birth
db.persons.find(
	{},
	{name: 1, yearOfBirth: 1, _id: 0}
).sort ( {yearOfBirth: 1} )

-- Show all persons, sorted in ascending order of their year of birth; suppress people with no yearOfBirth available.
db.persons.find (
	{yearOfBirth: {$exists: true} },
	{name: 1, yearOfBirth: 1, _id: 0}
).sort ( {yearOfBirth: 1} )

-- Show all persons, sorted in descending order of their year of birth
db.persons.find (
	{yearOfBirth: {$exists: true} },
	{name: 1, yearOfBirth: 1, _id: 0}
).sort ( {yearOfBirth: -1} )

-- Show all persons, sorted by last name and then first name
db.persons.find (
	{},
	{name: 1, _id: 0}
).sort ( {'name.last': 1, 'name.first': 1} )

-- Show persons, sorted by last name and then first name, limiting to first five people
db.persons.find (
	{},
	{name: 1, _id: 0}
).sort ( {'name.last': 1, 'name.first': 1} ).limit (5)


-- The following also gives the same output even though limit is written before sort. MongoDB shell always applies
-- limit clause after sort clause.
db.persons.find ( {}, {name: 1, _id: 0} ).limit(5).sort ( {'name.last': 1, 'name.first': 1} )

-- Show persons, sorted by last name and then first name, limiting to 6-10th persons only
db.persons.find (
	{},
	{name: 1, _id: 0}
).sort ( {'name.last': 1, 'name.first': 1} ).skip(5).limit (5)

-- Find and return only one document for a condition
db.persons.findOne ( {gender: 'F'}, {name: 1, _id: 0} )

-- The following, however, is an error: sort, limit, skip are not applicable with findOne.
db.persons.findOne ( {gender: 'F'}, {name: 1, _id: 0} ).sort ( {'yearOfBirth': 1} )

-- Specifying the _id field

db.persons.insert ( {_id: 101, name: {first: 'Robinson', last: 'Crusoe'} } )

-- Duplicate key error:
db.persons.insert ( {_id: 101, name: {first: 'Jonathan', middle: 'Livingstone', last: 'Seagull'} } )

-- _id can be a document itself
db.persons.insert ( {_id: {name: {first: 'Mary', last: 'Kym'}}, gender: 'F'})

-- Update. The following is bad as after this command the document only has the "married" field.
db.persons.update ( 
	{name: {first: 'Nancy', last: 'Karin'} },
	{married: 'Y'}
)
-- Let's reset it first to the original data:
db.persons.remove( {"_id" : ObjectId("523c0c8c378c940550e7cb43") } )
db.persons.insert ( {
	name: {first: 'Nancy', last: 'Karin'},
	gender: 'F',
	yearOfBirth: 1992,
	livesIn: 'Montreal',
	countriesVisited: ['Canada', 'United States of America'],
	languages: [
		{name: 'English', proficiency: 'Fluent'},
		{name: 'French', proficiency: 'Fluent'},
		{name: 'German', proficiency: 'Intermediate'},
		{name: 'Greek', proficiency: 'Intermediate'},
		{name: 'Latin', proficiency: 'Intermediate'},
		{name: 'Sanskrit', proficiency: 'Beginner'} ]
} )
db.persons.update ( 
	{name: {first: 'Nancy', last: 'Karin'} },
	{name: {first: 'Nancy', last: 'Karin'},
	gender: 'F',
	yearOfBirth: 1992,
	livesIn: 'Montreal',
	countriesVisited: ['Canada', 'United States of America'],
	languages: [
		{name: 'English', proficiency: 'Fluent'},
		{name: 'French', proficiency: 'Fluent'},
		{name: 'German', proficiency: 'Intermediate'},
		{name: 'Greek', proficiency: 'Intermediate'},
		{name: 'Latin', proficiency: 'Intermediate'},
		{name: 'Sanskrit', proficiency: 'Beginner'} ],
	married: 'Y' 
	}
)
-- But this is cumbersome. Better would be:
db.persons.update ( 
	{name: {first: 'Nancy', last: 'Karin'} },
	{$set: {married: 'N'} }
)

-- There is no such record, so collections remains unaffected, no error is returned either.
db.persons.update (
	{name: {first: 'Merilyn', last: 'Holmes'} },
	{$set: {gender: 'F', yearOfBirth: 1997, married: 'N'} }
)
-- This illustrates upsert operation
db.persons.update (
	{name: {first: 'Merilyn', last: 'Holmes'} },
	{$set: {gender: 'F', yearOfBirth: 1997, married: 'N'} },
	{upsert: true}
)

-- Single record update
db.persons.update (
	{'countriesVisited.0': 'India'},
	{$set: {nationality: 'Indian'} }
)
-- Multiple records update
db.persons.update (
	{'countriesVisited.0': 'India'},
	{$set: {nationality: 'Indian'} },
	{multi: true}
)

-- Remove a field from a document
db.persons.update (
	{name: {first: 'Nancy', last: 'Karin'} },
	{$unset: {married: 1} }
)

-- Set the first language of Nancy Karin to Portugese
db.persons.update (
	{name: {first: 'Nancy', last: 'Karin'} },
	{$set: {'languages.0.name': 'Portugese'} }
)

-- Just a placeholder for a frequent query. Not required to be part of documentation.
db.persons.find ({'name.first': 'Rita', 'name.last': 'Chauhan'} ).pretty()

-- Change Nancy Karin's language from German to Italian
db.persons.update (
	{'name.first': 'Nancy', 'name.last': 'Karin', 'languages.name': 'German'},
	{$set: {'languages.$.name': 'Italian'} }
)

-- Change Italian back to German, and make her fluent in German
db.persons.update ( 
	{name: {first: 'Nancy', last: 'Karin'}, 'languages.name': 'Italian'},
	{$set: {'languages.$': {name: 'German', proficiency: 'Expert'} }
} )

-- Adding Beginner level proficiency in Spanish for Rita Chauhan
db.persons.update (
	{'name.first': 'Rita', 'name.last': 'Chauhan'},
	{$push: {languages: {name: 'Spanish', proficiency: 'Beginner' } } }
)

-- Increment / set a field value

db.persons.update (
	{'name.first': 'Rita', 'name.last': 'Chauhan'},
	{$inc: {children: 1} }
)

-- Renaming a field.
db.persons.find ( {livesIn: 'Gangtok'} )
-- The above does not find a record. Reason: wrongly spelt field name as 'lievsIn' for one record. Let's fix that
db.persons.update (
	{},
	{$rename: {'lievsIn': 'livesIn'}},
	{multi: true}
)

-- Similarly, subdocument fields can be renamed also
db.persons.update (
	{},
	{$rename: {'name.first': 'name.fname'} },
	{multi: true}
)
-- Roll it back
db.persons.update (
	{},
	{$rename: {'name.fname': 'name.first'} },
	{multi: true}
)

-- Renaming multiple field names
db.persons.update (
	{},
	{$rename: {'name.first': 'name.fname', 'name.last': 'name.lname', yearOfBirth: 'birthYear'} },
	{multi: true}
)
-- Roll it back
db.persons.update (
	{},
	{$rename: {'name.fname': 'name.first', 'name.lname': 'name.last', birthYear: 'yearOfBirth'} },
	{multi: true}
)

-- Fields can be renamed / moved outside a subdocument an vice-verse also.
db.persons.update (
	{},
	{$rename: {'name.first': 'firstname', 'name.last': 'lastname'} },
	{multi: true}
)
-- Drop the empty "name" subdocument.
db.persons.update (
	{},
	{$unset: {name: 'anyjunkcanbegivenhere doesnotmatter'} },
	{multi: true}
)
-- Roll back everything.
db.persons.update (
	{},
	{$rename: {firstname: 'name.first', lastname: 'name.last'} },
	{multi: true}
)
		
-- Narayan Sundaram, Rita Chauhan and Liza Bordelon have enrolled for Sanskrit classes, so they should all be marked as having
-- beginner level proficiency in Sanskrit. Out of these Liza Bordelon already has this, so should not be duplicated.
db.persons.update (
	{name: {$in: [
		{first: 'Narayan', last: 'Sundaram'},
		{first: 'Rita', last: 'Chauhan'},
		{first: 'Liza', last: 'Bordelon'}
	] } },
	{$addToSet: {languages: {name: 'Sanskrit', proficiency: 'Beginner'} } },
	{multi: true}
)

-- Add multiple languages to Neeharika Chauhan

db.persons.update ( 
	{'name.first': 'Neeharika', 'name.last': 'Chauhan'}, 
	{$push: 
		{languages: 
			{$each: [
				{name: 'Marathi', proficiency: 'Fluent'},
				{name: 'Gujrati'},
				{name: 'Punjabi', proficiency: 'Intermediate'}
] } } } )

-- Remove the last language for Nancy Karin
db.persons.update ( {'name.first': 'Nancy', 'name.last': 'Karin'}, {$pop: {languages: 1}})

-- Remove the first language for Nancy Karin
db.persons.update ( {'name.first': 'Nancy', 'name.last': 'Karin'}, {$pop: {languages: -1}})

-- Add languages for Nancy Karin and keep the data sorted

db.persons.update ( 
	{'name.first': 'Nancy', 'name.last': 'Karin'},
	{$push: {languages: {$each: [
		{name: 'Marathi', proficiency: 'Beginner'},
		{name: 'Gujrati', proficiency: 'Beginner'} ],
		$sort: {name: 1} } } }
)

-- Add some more languages for Nancy Karin, sort the data, and keep only the first three

db.persons.update ( 
	{'name.first': 'Nancy', 'name.last': 'Karin'},
	{$push: {languages: {$each: [
		{name: 'Sindhi', proficiency: 'Beginner'},
		{name: 'Tullu', proficiency: 'Beginner'} ],
		$sort: {name: 1}, $slice: 3 } } }
)

-- For all documents in the 'person” collection, we want the array “languages” to be sorted by language name. 
		
db.persons.update ( {},
	{$push: {languages: {$each: [], $sort: {name: 1} } } },
	{multi: true}
)

-- save operation
db.persons.save ( {name: {first: 'Jonathan', middle: 'Livingstone', last: 'Seagull'} } )
db.persons.save ( {_id: 102, name: {first: 'Vishnudutt', last: 'Sharma'} } )
db.persons.save ( {_id: 102, gender: 'M'} )
db.persons.save ( {_id: 102, name: {first: 'Vishnudutt', last: 'Sharma'}, gender: 'M'} )

-- findAndModify
db.persons.findAndModify ( {
	query: {$and: [{'name.first': 'Zoa'}, {'name.last': 'Hendrik'}]},
	remove: true,
	update: {$set: {livesIn: 'Madrid'} }
} )

db.persons.findAndModify ( {
	query: {'name.first': 'Zoa'},
	update: {$set {yearOfBirth: 1950} }
} )

-- Remove all males
db.persons.remove ( {gender: 'M'} )
-- Drop the collection; copy all data back into the collection

-- Remove just one male
db.persons.remove ( {gender: 'M'}, 1)

-- Remove all documents
db.persons.remove()
-- Better to drop the collection
db.persons.drop()

-- Rename a collection
db.zip.renameCollection("zips")

